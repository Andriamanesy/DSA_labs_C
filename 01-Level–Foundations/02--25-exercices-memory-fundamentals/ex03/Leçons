Non, une boucle standard n'utilise pas la pile (stack) ind√©finiment.

C'est l√† une distinction cruciale √† comprendre pour un ing√©nieur : **la diff√©rence entre l'it√©ration (boucle) et la r√©cursion.**

### 1. La Boucle (It√©ration) : Consommation fixe

Dans une boucle `while` ou `for`, peu importe que tu fasses 10 tours ou 10 milliards de tours, tu r√©utilises la **m√™me case m√©moire** sur la pile.

```c
void boucle_infinie() {
    int i = 0; // Une seule case sur la Stack
    while (1) {
        i++; // On modifie la valeur de la case, mais on n'en cr√©e pas de nouvelle.
    }
}

```

Ici, ton programme ne plantera **jamais** pour un Stack Overflow. Il tournera juste ind√©finiment en utilisant toujours les m√™mes 4 octets pour `i`.

---

### 2. La R√©cursion : Consommation cumulative

Dans une r√©cursion, chaque fois que la fonction s'appelle elle-m√™me, l'ordinateur doit "sauvegarder" l'√©tat de la fonction actuelle pour pouvoir y revenir plus tard.

* Il doit m√©moriser l'adresse de retour (o√π reprendre apr√®s l'appel).
* Il doit cr√©er de nouvelles copies des variables locales pour ce nouvel appel.

```c
void recursion_infinie(int i) {
    int locale = i; // Nouvelle case cr√©√©e sur la Stack √† CHAQUE appel
    recursion_infinie(i + 1);
}

```

C'est comme si tu empilais des assiettes. √Ä un moment, la pile d'assiettes touche le plafond. C'est ce que tu as vu avec ton crash √† 261 000 appels.

---

### 3. Pourquoi c'est important ?

* **En Python ou JS** : La limite de r√©cursion est tr√®s basse (souvent 1000 appels). Les boucles sont donc pr√©f√©r√©es.
* **En C (√† 42)** : Tu utiliseras la r√©cursion pour des algorithmes comme le *backtracking* (r√©soudre un Sudoku) ou pour parcourir des arbres. Tu dois t'assurer que ta r√©cursion n'est pas trop profonde.

### üí° Le cas particulier : "Tail Call Optimization"

Certains compilateurs tr√®s intelligents transforment parfois une r√©cursion en boucle en arri√®re-plan pour √©conomiser la pile, mais en C avec les flags de 42, on ne compte pas l√†-dessus : on g√®re sa m√©moire manuellement !

---

### üèÅ Alors, on attaque les Linked Lists ?

Les listes cha√Æn√©es sont le parfait m√©lange : on utilise la **Heap** pour stocker les donn√©es, et on utilise souvent des **boucles** pour les parcourir sans faire exploser la **Stack**.
