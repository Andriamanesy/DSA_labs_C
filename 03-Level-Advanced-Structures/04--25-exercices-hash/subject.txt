La table de hachage (**Hash Table**) est la structure de données la plus utilisée pour obtenir des performances de recherche en temps constant . En C, c'est un défi de taille car vous devez gérer vous-même les collisions et la fonction de hachage.

Voici 25 exercices pour maîtriser le hachage.

---

### I. Fonctions de Hachage et Fondamentaux

1. **Hachage de Somme :** Créez une fonction qui hache une chaîne en additionnant les valeurs ASCII de ses caractères. Identifiez pourquoi c'est une mauvaise fonction (collisions).
2. **Fonction DJB2 :** Implémentez la célèbre fonction de hachage `djb2` et comparez sa répartition avec l'exercice 1.
3. **Modulo et Taille :** Écrivez un programme qui démontre l'importance d'utiliser une taille de table nombre premier pour réduire les collisions.
4. **Hachage d'Entiers :** Implémentez la méthode de hachage par multiplication pour des clés entières.
5. **Hachage de Structures :** Créez une fonction qui génère un index à partir d'une structure `struct Date {int d, m, y;}`.

### II. Gestion des Collisions (Adressage Ouvert)

6. **Sondage Linéaire (Linear Probing) :** Implémentez l'insertion dans une table où, en cas de collision, on cherche la prochaine case libre.
7. **Recherche et Suppression :** Implémentez la recherche et la suppression pour le sondage linéaire (attention au "trou" laissé par une suppression !).
8. **Sondage Quadratique :** Modifiez votre table pour utiliser un saut au carré () afin d'éviter le regroupement primaire.
9. **Double Hachage :** Utilisez une seconde fonction de hachage pour calculer l'intervalle de saut en cas de collision.
10. **Analyse du Facteur de Charge :** Écrivez une fonction qui calcule le ratio (éléments occupés / taille totale) et affiche une alerte au-dessus de 0.7.

### III. Gestion des Collisions (Chaînage Séparé)

11. **Table à Listes Chaînées :** Créez une table de hachage où chaque case est un pointeur vers une liste chaînée (Buckets).
12. **Recherche par Clé :** Implémentez la recherche d'une valeur associée à une chaîne de caractères dans une table avec chaînage.
13. **Suppression Propre :** Gérez la libération mémoire d'un nœud spécifique dans une liste de collision sans perdre le reste de la chaîne.
14. **Comptage de Collisions :** Affichez la longueur de la chaîne la plus longue dans votre table pour mesurer l'efficacité de votre fonction de hachage.
15. **Table de Hachage de Structures :** Stockez des structures `User` (ID, pseudo, email) en utilisant le pseudo comme clé.

### IV. Redimensionnement et Optimisation

16. **Rehashing Dynamique :** Lorsque le facteur de charge dépasse 0.75, créez une nouvelle table deux fois plus grande et ré-insérez tous les éléments.
17. **Dictionnaire de Mots :** Chargez un fichier dictionnaire (type `/usr/share/dict/words`) dans une table de hachage et mesurez le temps de recherche d'un mot.
18. **Suppression de Doublons :** Utilisez une table de hachage pour supprimer les doublons d'un tableau de 10 000 entiers en un seul parcours.
19. **Intersection de deux Tableaux :** Trouvez les éléments communs à deux grands tableaux en utilisant une table de hachage pour optimiser la complexité.
20. **Fréquence des mots :** Lisez un texte et utilisez une table de hachage pour compter le nombre d'occurrences de chaque mot.

### V. Concepts Avancés

21. **Hachage Universel :** Implémentez un système où la fonction de hachage est choisie aléatoirement parmi une famille de fonctions à l'exécution.
22. **Bloom Filter :** Implémentez un filtre de Bloom (une variante probabiliste de la table de hachage) pour vérifier très rapidement si un élément *n'est pas* dans un ensemble.
23. **Table de Hachage Ordonnée :** Modifiez votre table pour pouvoir itérer sur les éléments dans leur ordre d'insertion (nécessite une liste doublement chaînée auxiliaire).
24. **Cuckoo Hashing :** Implémentez le hachage "coucou" (deux tables, deux fonctions de hachage, les éléments se déplacent si leur place est prise).
25. **Cache LRU avec Hash :** Combinez une table de hachage et une liste doublement chaînée pour créer un cache LRU (Least Recently Used) où l'accès et la mise à jour sont en .

---

### Le défi du développeur C

La plus grande difficulté ici est la **gestion de la mémoire des clés**. Si vous utilisez des chaînes de caractères (`char *`) comme clés, devez-vous copier la chaîne (`strdup`) ou simplement stocker le pointeur ? L'exercice **13** et **16** vous apprendront à ne jamais laisser de fuite mémoire lors des manipulations de buckets.

**Souhaitez-vous que je vous montre comment implémenter une structure de base pour le chaînage séparé (Exercice 11) ? C'est la méthode la plus robuste en C.**
