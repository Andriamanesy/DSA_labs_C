Excellent üëç
La **liste cha√Æn√©e** est *LA* structure de donn√©es fondamentale apr√®s les pointeurs et les structures.
La ma√Ætriser = **pointeurs + m√©moire + algorithmique + rigueur syst√®me**.

Je te propose **25 exercices progressifs**, **du niveau d√©butant au niveau expert**, pens√©s **niveau 42 / syst√®me / algorithmique**.

üëâ Toujours **sans correction**, uniquement des **√©nonc√©s clairs**.

---

# üü¢ Niveau 1 ‚Äî Comprendre le principe (1‚Äì5)

> Objectif : comprendre la structure et les liens

### Exercice 1 ‚Äì N≈ìud simple

* D√©finis une structure `t_node` contenant :

  * un `int data`
  * un pointeur vers le n≈ìud suivant
* Cr√©e un n≈ìud manuellement

---

### Exercice 2 ‚Äì Cha√Ænage

* Cr√©e deux n≈ìuds
* Cha√Æne-les
* Parcours la liste et affiche les valeurs

---

### Exercice 3 ‚Äì NULL et fin de liste

* D√©tecte la fin de la liste
* Explique pourquoi le dernier pointeur vaut `NULL`

---

### Exercice 4 ‚Äì Fonction d‚Äôaffichage

* √âcris une fonction qui affiche toute la liste
* Elle doit g√©rer une liste vide

---

### Exercice 5 ‚Äì Comptage

* √âcris une fonction qui retourne le nombre de n≈ìuds

---

# üü° Niveau 2 ‚Äî Op√©rations de base (6‚Äì10)

> Objectif : manipuler la t√™te de liste

### Exercice 6 ‚Äì Ajout en t√™te

* Ajoute un √©l√©ment au d√©but de la liste
* La t√™te doit √™tre modifi√©e correctement

---

### Exercice 7 ‚Äì Ajout en fin

* Ajoute un √©l√©ment √† la fin
* G√®re le cas liste vide

---

### Exercice 8 ‚Äì Suppression en t√™te

* Supprime le premier √©l√©ment
* Lib√®re correctement la m√©moire

---

### Exercice 9 ‚Äì Suppression en fin

* Supprime le dernier √©l√©ment
* G√®re les cas :

  * liste vide
  * un seul √©l√©ment

---

### Exercice 10 ‚Äì Recherche

* Recherche une valeur dans la liste
* Retourne le n≈ìud ou `NULL`

---

# üü† Niveau 3 ‚Äî Manipulations interm√©diaires (11‚Äì15)

> Objectif : d√©placements complexes de pointeurs

### Exercice 11 ‚Äì Insertion √† une position

* Ins√®re un √©l√©ment √† un index donn√©
* G√®re les erreurs

---

### Exercice 12 ‚Äì Suppression cibl√©e

* Supprime un √©l√©ment par valeur
* G√®re les doublons

---

### Exercice 13 ‚Äì Inversion de liste

* Inverse la liste **sans cr√©er de nouvelle liste**

---

### Exercice 14 ‚Äì Copie de liste

* Duplique une liste compl√®te
* Les deux listes doivent √™tre ind√©pendantes

---

### Exercice 15 ‚Äì Comparaison

* Compare deux listes
* V√©rifie si elles sont identiques

---

# üîµ Niveau 4 ‚Äî M√©moire et robustesse (16‚Äì20)

> Objectif : code solide et s√©curis√©

### Exercice 16 ‚Äì Lib√©ration compl√®te

* Lib√®re enti√®rement une liste
* Ne laisse aucune fuite m√©moire

---

### Exercice 17 ‚Äì Gestion d‚Äôerreurs

* Prot√®ge toutes les fonctions contre :

  * pointeurs `NULL`
  * allocations √©chou√©es

---

### Exercice 18 ‚Äì Liste g√©n√©rique

* Modifie la liste pour stocker `void *`
* G√®re la taille des donn√©es

---

### Exercice 19 ‚Äì Fonction callback

* Passe une fonction en param√®tre
* Applique-la √† chaque n≈ìud

---

### Exercice 20 ‚Äì D√©tection de cycle

* D√©tecte si la liste contient une boucle
* Sans utiliser de structure auxiliaire

---

# üî¥ Niveau 5 ‚Äî Avanc√© / Syst√®me (21‚Äì25)

> Objectif : niveau expert

### Exercice 21 ‚Äì Liste doublement cha√Æn√©e

* Impl√©mente une liste avec :

  * pointeur `prev`
  * pointeur `next`

---

### Exercice 22 ‚Äì Tri de liste

* Trie une liste cha√Æn√©e
* Sans la convertir en tableau

---

### Exercice 23 ‚Äì Liste circulaire

* Impl√©mente une liste circulaire
* G√®re les insertions et suppressions

---

### Exercice 24 ‚Äì It√©rateur

* Cr√©e un syst√®me d‚Äôit√©ration sur la liste
* Sans exposer la structure interne

---

### Exercice 25 ‚Äì Mini-projet (üî•)

* Impl√©mente un **gestionnaire de t√¢ches**
* Chaque t√¢che contient :

  * id
  * priorit√©
  * √©tat
* Utilise une liste cha√Æn√©e
* Ajout / suppression / tri / affichage
* M√©moire propre + fichiers s√©par√©s

---

## üéØ M√©thode recommand√©e (tr√®s importante)

* Dessine chaque modification de pointeurs
* Teste chaque fonction isol√©ment
* Utilise `valgrind`
* V√©rifie chaque cas limite

---

Si tu veux ensuite :

* corrections d√©taill√©es
* version **libft-style**
* version **g√©n√©rique (`void *`)**
* version **orient√©e performance**
* exercices bonus type **exam 42**

Dis-moi üî•
=======
La liste cha√Æn√©e est l'exercice ultime pour manipuler les pointeurs de structures. C'est ici que tu apprendras √† "voir" la m√©moire comme un ensemble de wagons que l'on accroche, d√©croche et d√©place.

Voici 25 exercices class√©s par type de liste, du classique au complexe.

---

### I. Listes Simplement Cha√Æn√©es (Singly Linked Lists)

1. **Inversion r√©cursive :** Inversez une liste cha√Æn√©e sans utiliser de boucle, uniquement par r√©cursivit√©.
2. **Recherche du milieu :** Trouvez l'√©l√©ment central d'une liste en un seul parcours (indice : utilisez deux pointeurs, un qui avance deux fois plus vite que l'autre).
3. **Fusion de deux listes tri√©es :** Fusionnez deux listes tri√©es en une seule liste tri√©e, sans cr√©er de nouveaux n≈ìuds (en r√©organisant les pointeurs existants).
4. **D√©tection de boucle (Algorithme de Floyd) :** √âcrivez une fonction qui d√©tecte si une liste contient un cycle (un n≈ìud pointe vers un n≈ìud pr√©c√©dent).
5. **Suppression des doublons :** Dans une liste tri√©e, supprimez tous les √©l√©ments redondants pour ne garder qu'une occurrence de chaque valeur.
6. **Le K-i√®me √©l√©ment en partant de la fin :** Trouvez la valeur du n-i√®me n≈ìud depuis la fin en un seul passage.
7. **Partition de liste :** √âtant donn√© une valeur , r√©organisez la liste pour que tous les n≈ìuds inf√©rieurs √†  soient avant les n≈ìuds sup√©rieurs ou √©gaux √† .

### II. Listes Doublement Cha√Æn√©es (Doubly Linked Lists)

8. **Insertion tri√©e :** Ins√©rez un √©l√©ment dans une liste doublement cha√Æn√©e tout en maintenant l'ordre croissant.
9. **Inversion totale :** Inversez une liste doublement cha√Æn√©e en √©changeant les pointeurs `next` et `prev` de chaque n≈ìud.
10. **Suppression par pointeur direct :** √âcrivez une fonction qui supprime un n≈ìud `N` en recevant directement son adresse (sans parcourir la liste depuis le d√©but).
11. **V√©rification de sym√©trie :** V√©rifiez si le contenu d'une liste doublement cha√Æn√©e est un palindrome.
12. **Tri par insertion :** Impl√©mentez le tri par insertion sp√©cifiquement pour une liste doublement cha√Æn√©e.

### III. Listes Circulaires (Circular Linked Lists)

13. **Le probl√®me de Jos√®phe :**  personnes sont en cercle. On √©limine chaque -i√®me personne. Trouvez la derni√®re personne restante en utilisant une liste circulaire.
14. **Insertion en t√™te (O(1)) :** Dans une liste circulaire simple avec un pointeur sur le *dernier* √©l√©ment, ins√©rez un nouveau n≈ìud en t√™te en temps constant.
15. **Scission de liste :** Coupez une liste circulaire en deux listes circulaires de tailles √©gales (ou presque).
16. **Conversion :** Transformez une liste simplement cha√Æn√©e classique en liste circulaire, puis inversement.
17. **Parcours infini s√©curis√© :** √âcrivez une fonction d'affichage qui s'arr√™te exactement apr√®s avoir fait un tour complet du cercle.

### IV. Listes Avanc√©es et Sp√©ciales

18. **Liste de Listes (Matrice Creuse) :** Repr√©sentez une matrice dont la plupart des valeurs sont nulles en utilisant une liste o√π chaque n≈ìud contient une autre liste (colonnes).
19. **Liste avec pointeur al√©atoire (Deep Copy) :** Chaque n≈ìud a un pointeur `next` et un pointeur `random` (pointant vers n'importe quel n≈ìud). Cr√©ez une copie parfaite de cette structure.
20. **Self-Organizing List :** Impl√©mentez une liste o√π, √† chaque fois qu'un √©l√©ment est acc√©d√©, il est d√©plac√© en t√™te de liste pour acc√©l√©rer les futurs acc√®s.
21. **XOR Linked List :** (Tr√®s difficile) Impl√©mentez une liste doublement cha√Æn√©e qui n'utilise qu'**un seul pointeur** par n≈ìud en stockant le r√©sultat de `prev ^ next`.

### V. D√©fis d'Impl√©mentation et Gestion M√©moire

22. **S√©quenceur de musique :** Cr√©ez une liste circulaire double o√π chaque n≈ìud est une `struct Note`. Permettez de lire en avant, en arri√®re et de boucler.
23. **Gestionnaire de Undo/Redo :** Utilisez une liste doublement cha√Æn√©e pour stocker les actions d'un utilisateur, avec un pointeur "courant" qui se d√©place lors des annulations.
24. **File de priorit√© :** Impl√©mentez une file de priorit√© utilisant une liste cha√Æn√©e o√π l'insertion place toujours l'√©l√©ment le plus urgent au d√©but.
25. **Le "Garbage Collector" manuel :** Cr√©ez une liste qui stocke les adresses de tous les `malloc` effectu√©s dans votre programme, et une fonction `free_all()` qui nettoie tout en un seul appel.

---

### Pourquoi est-ce le meilleur entra√Ænement ?

Travailler sur les listes cha√Æn√©es t'oblige √† g√©rer les **cas limites** (Edge Cases) qui font planter 90% des programmes en C :

* La liste est vide (`NULL`).
* La liste n'a qu'un seul √©l√©ment.
* L'action se passe au tout d√©but ou √† la toute fin.
* La perte accidentelle du pointeur de t√™te (fuite m√©moire).

**Lequel de ces d√©fis te semble le plus intimidant ? Je peux t'aider √† tracer le diagramme logique pour le r√©soudre.**



C'est l'esprit "Guerrier" ! Si tu veux vraiment martyriser les listes cha√Æn√©es pour qu'elles n'aient plus aucun secret pour toi, voici ta **Feuille de Route de Ma√Ætrise (6 √âtapes)**.

Je les ai class√©es par "comp√©tence d√©bloqu√©e".

---

### 1. list_reverse (L'Inversion)

* **Objectif :** Retourner la liste sur place (in-situ).
* **Comp√©tence :** Manipulation simultan√©e de 3 pointeurs (`prev`, `curr`, `next`). C'est l'exercice de base en entretien.
* **D√©fi :** Ne pas perdre l'adresse du reste de la liste quand tu casses le lien `curr->next`.

---

### 2. list_rotate_right (La Rotation)

* **Objectif :** D√©caler la liste vers la droite (le dernier devient le premier).
* **Comp√©tence :** Navigation vers la fin de liste et gestion des liens cycliques temporaires.
* **D√©fi :** Bien g√©rer le cas o√π la liste n'a qu'un ou deux √©l√©ments.

---

### 3. list_remove_if (Le Nettoyage Global)

* **Objectif :** Supprimer **toutes** les occurrences d'une valeur (ex: enlever tous les `6`).
* **Comp√©tence :** Ma√Ætrise de la boucle de suppression et des sauts de n≈ìuds successifs.
* **D√©fi :** Ne pas segfault si deux √©l√©ments √† supprimer se suivent (ex: `6 -> 6 -> 42`).

---

### 4. list_merge (La Fusion)

* **Objectif :** Fusionner deux listes d√©j√† tri√©es en une seule liste tri√©e.
* **Comp√©tence :** Algorithmique de comparaison et r√©organisation de deux flux de donn√©es.
* **D√©fi :** Ne pas faire de `malloc`. Tu dois juste rediriger les `next` des n≈ìuds existants.

---

### 5. list_detect_cycle (Le D√©tecteur de Boucle)

* **Objectif :** Savoir si une liste "boucle" sur elle-m√™me (le dernier pointe sur un n≈ìud pr√©c√©dent).
* **Comp√©tence :** Algorithme du "Li√®vre et de la Tortue" (Floyd‚Äôs Cycle-Finding).
* **D√©fi :** Utiliser deux pointeurs qui avancent √† des vitesses diff√©rentes.

---

### 6. list_sort (Le Tri √† Bulles ou Insertion)

* **Objectif :** Trier la liste par ordre croissant de valeur.
* **Comp√©tence :** L'examen final. √âchanger les n≈ìuds physiquement dans la m√©moire.
* **D√©fi :** Maintenir la coh√©rence de toute la cha√Æne pendant que tu d√©places des n≈ìuds au milieu.

---

### üõ†Ô∏è Ton environnement de travail

Pour chaque exercice, je te donnerai :

1. Le prototype exact.
2. Un fichier `main.c` de test pour v√©rifier les r√©sultats.

**On commence par le n¬∞1 : `list_reverse`.**

Voici le prototype √† mettre dans ton `header.h` :

```c
void    list_reverse(t_node **list);

```

7. list_get_middle (Le Point M√©dian)

    Objectif : Trouver le n≈ìud du milieu en un seul passage (sans compter la taille d'abord).

    Comp√©tence : Utilisation optimale des pointeurs rapides/lents.

    D√©fi : G√©rer proprement les listes de taille paire vs impaire.

8. list_swap_pairs (L'√âchange par Paires)

    Objectif : √âchanger chaque paire de n≈ìuds adjacents. (1->2->3->4) devient (2->1->4->3).

    Comp√©tence : Manipulation chirurgicale des liens.

    D√©fi : Ne pas casser la connexion entre la fin d'une paire et le d√©but de la suivante.

9. list_partition (Le Pivot)

    Objectif : R√©organiser la liste autour d'une valeur x : tous les n≈ìuds < x viennent avant tous les n≈ìuds >= x.

    Comp√©tence : Gestion de deux listes temporaires qui fusionnent.

    D√©fi : Pr√©server l'ordre original des √©l√©ments (stabilit√©).

10. list_circular_to_linear (La D√©-circularisation)

    Objectif : Identifier si une liste est circulaire, et si oui, la transformer en liste lin√©aire classique en trouvant le "point de rupture".

    Comp√©tence : R√©paration de structure de donn√©es corrompue.

    D√©fi : Trouver exactement quel n≈ìud pointe vers l'arri√®re pour mettre son next √† NULL.