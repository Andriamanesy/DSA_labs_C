Parfait üëç
La **PILE (stack)** est une structure **fondamentale en informatique syst√®me**, tr√®s utilis√©e en C, algorithmique, parsing, VM, compilateurs, etc.
La ma√Ætriser = **pointeurs + m√©moire + discipline LIFO**.

Je te propose **25 exercices progressifs**, **du niveau d√©butant au niveau expert**, pens√©s **niveau 42 / syst√®me / algorithmique**.

üëâ Toujours **sans correction**, uniquement des **√©nonc√©s clairs**, structur√©s pour une vraie mont√©e en comp√©tence.

---

# üü¢ Niveau 1 ‚Äî Comprendre le principe LIFO (1‚Äì5)

> Objectif : comprendre ce qu‚Äôest une pile et ses op√©rations de base

### Exercice 1 ‚Äì Concept LIFO

* Explique le principe **Last In First Out**
* Donne 3 exemples concrets d‚Äôutilisation d‚Äôune pile

---

### Exercice 2 ‚Äì Structure de pile simple

* Cr√©e une structure repr√©sentant une pile :

  * valeur
  * pointeur vers l‚Äô√©l√©ment suivant

---

### Exercice 3 ‚Äì Pile vide

* √âcris une fonction qui v√©rifie si la pile est vide

---

### Exercice 4 ‚Äì Push (empiler)

* Impl√©mente l‚Äôop√©ration `push`
* Le nouvel √©l√©ment doit devenir le sommet

---

### Exercice 5 ‚Äì Pop (d√©piler)

* Impl√©mente l‚Äôop√©ration `pop`
* Lib√®re correctement la m√©moire

---

# üü° Niveau 2 ‚Äî Op√©rations essentielles (6‚Äì10)

> Objectif : manipuler correctement le sommet de pile

### Exercice 6 ‚Äì Peek

* Impl√©mente une fonction qui retourne la valeur du sommet
* Sans modifier la pile

---

### Exercice 7 ‚Äì Taille de la pile

* √âcris une fonction qui retourne le nombre d‚Äô√©l√©ments

---

### Exercice 8 ‚Äì Affichage

* Affiche la pile du sommet vers la base

---

### Exercice 9 ‚Äì Gestion d‚Äôerreurs

* G√®re les cas :

  * pop sur pile vide
  * push avec allocation √©chou√©e

---

### Exercice 10 ‚Äì Nettoyage

* Lib√®re enti√®rement la pile
* La pile finale doit √™tre vide

---

# üü† Niveau 3 ‚Äî Utilisation algorithmique (11‚Äì15)

> Objectif : utiliser la pile pour r√©soudre des probl√®mes

### Exercice 11 ‚Äì Inversion

* Inverse une pile √† l‚Äôaide d‚Äôune autre pile

---

### Exercice 12 ‚Äì Parenth√®ses

* V√©rifie si une expression est bien parenth√©s√©e
* Utilise une pile

---

### Exercice 13 ‚Äì Notation postfix√©e

* √âvalue une expression en notation postfix√©e (RPN)
* Utilise une pile d‚Äôentiers

---

### Exercice 14 ‚Äì Conversion

* Convertis une expression infixe en postfix√©e
* Utilise une pile

---

### Exercice 15 ‚Äì Backtracking simple

* Utilise une pile pour explorer des possibilit√©s
* Exemple : labyrinthe simple

---

# üîµ Niveau 4 ‚Äî Impl√©mentations avanc√©es (16‚Äì20)

> Objectif : ma√Ætrise m√©moire et abstraction

### Exercice 16 ‚Äì Pile avec tableau

* Impl√©mente une pile avec un tableau dynamique
* G√®re le d√©bordement

---

### Exercice 17 ‚Äì Redimensionnement

* Impl√©mente une pile dynamique qui s‚Äôagrandit automatiquement

---

### Exercice 18 ‚Äì Pile g√©n√©rique

* Impl√©mente une pile utilisant `void *`
* G√®re la taille des √©l√©ments

---

### Exercice 19 ‚Äì Callback

* Passe une fonction en param√®tre
* Applique-la √† chaque √©l√©ment de la pile

---

### Exercice 20 ‚Äì S√©curit√© m√©moire

* Teste ta pile avec `valgrind`
* Corrige toutes les erreurs d√©tect√©es

---

# üî¥ Niveau 5 ‚Äî Expert / Syst√®me (21‚Äì25)

> Objectif : niveau professionnel

### Exercice 21 ‚Äì Pile de structures

* Utilise une pile pour stocker des structures complexes

---

### Exercice 22 ‚Äì Undo / Redo

* Impl√©mente un syst√®me undo/redo
* Utilise deux piles

---

### Exercice 23 ‚Äì Appels de fonctions

* Simule une pile d‚Äôappels de fonctions
* Chaque frame contient :

  * nom de fonction
  * variables locales

---

### Exercice 24 ‚Äì Pile thread-safe

* Rends ta pile utilisable en environnement multi-thread
* (mutex)

---

### Exercice 25 ‚Äì Mini-projet (üî•)

* Impl√©mente un **interpr√©teur de commandes**
* Utilise une pile pour :

  * parsing
  * ex√©cution
* Code modulaire (`.h / .c`)
* Gestion m√©moire parfaite

---

## üéØ M√©thode recommand√©e

* Toujours penser **sommet de pile**
* Tracer chaque `push` / `pop`
* Tester chaque fonction s√©par√©ment
* V√©rifier les cas limites

---

Si tu veux ensuite :

* corrections compl√®tes
* version **liste cha√Æn√©e**
* version **tableau**
* version **g√©n√©rique**
* tests type **exam 42**

Dis-moi üöÄ
=======
La **Pile (Stack)** est le concept fondamental du "LIFO" (*Last In, First Out*). Bien que sa structure semble simple, son impl√©mentation robuste et son utilisation dans des algorithmes complexes sont essentielles pour comprendre comment les ordinateurs ex√©cutent le code (notamment la r√©cursivit√©).

Voici 25 exercices pour devenir un expert de la Pile en C.

---

### I. Impl√©mentation de Base (L'Architecture)

1. **Pile Statique :** Impl√©mentez une pile utilisant un tableau de taille fixe et une structure contenant un indice `top`.
2. **Pile Dynamique (malloc) :** Cr√©ez une pile qui s'agrandit automatiquement (double de taille) lorsque le tableau est plein.
3. **Pile par Liste Cha√Æn√©e :** Impl√©mentez `push` et `pop` en utilisant une liste simplement cha√Æn√©e (insertion et suppression en t√™te en ).
4. **Pile G√©n√©rique :** Utilisez des pointeurs `void *` pour que votre pile puisse stocker n'importe quel type de donn√©e (int, char, struct).
5. **Gestion d'erreurs :** Ajoutez des s√©curit√©s pour g√©rer les cas de `Stack Overflow` (pile pleine) et `Stack Underflow` (pile vide).

### II. Algorithmes Classiques (V√©rification et Syntaxe)

6. **√âquilibrage des Parenth√®ses :** √âcrivez un programme qui v√©rifie si une cha√Æne contenant `()`, `[]` et `{}` est correctement parenth√©s√©e.
7. **Inversion de cha√Æne :** Utilisez une pile pour inverser une cha√Æne de caract√®res.
8. **Palindrome :** V√©rifiez si un mot est un palindrome en utilisant une pile.
9. **Conversion D√©cimal vers Binaire :** Utilisez une pile pour stocker les restes des divisions successives par 2.
10. **Suppression des doublons adjacents :** Dans une cha√Æne comme "abbaca", utilisez une pile pour supprimer les lettres identiques c√¥te √† c√¥te jusqu'√† obtenir "ca".

### III. √âvaluation d'Expressions (Le c≈ìur du sujet)

11. **Notation Polonaise Inverse (RPN) :** √âvaluez une expression postfixe (ex: `5 3 + 2 *` donne 16).
12. **Conversion Infixe vers Postfixe :** Transformez une expression classique `(A + B) * C` en `A B + C *` (Algorithme Shunting-yard).
13. **Conversion Infixe vers Pr√©fixe :** M√™me exercice, mais pour la notation pr√©fixe.
14. **Calculatrice Multi-op√©rateurs :** G√©rez la priorit√© des op√©rateurs (`*` et `/` avant `+` et `-`) avec une pile.
15. **√âvaluation d'expression avec parenth√®ses :** √âtendez votre calculatrice pour g√©rer les niveaux de priorit√© parenth√©s√©s.

### IV. Manipulations de Piles (Logique Pure)

16. **Inversion de Pile :** Inversez l'ordre des √©l√©ments d'une pile en utilisant uniquement les fonctions `push` et `pop` (et la r√©cursivit√© !).
17. **Tri d'une Pile :** Triez une pile de sorte que les plus grands √©l√©ments soient au-dessus, en utilisant une seconde pile temporaire.
18. **Le plus petit √©l√©ment (Min Stack) :** Cr√©ez une pile qui retourne l'√©l√©ment minimum en  sans parcourir toute la pile.
19. **Deux Piles, Un Tableau :** Impl√©mentez deux piles dans un seul tableau de taille , l'une commen√ßant au d√©but et l'autre √† la fin, pour optimiser l'espace.
20. **File (Queue) avec deux Piles :** Simulez le comportement d'une file (FIFO) en utilisant uniquement deux piles.

### V. Cas d'Usage Avanc√©s et Syst√®me

21. **Parcours de Graphe It√©ratif (DFS) :** Impl√©mentez le parcours en profondeur d'un graphe ou d'un arbre en utilisant votre propre pile au lieu de la r√©cursivit√©.
22. **Simulation d'Appels Syst√®me :** Cr√©ez une structure qui simule la "Call Stack" d'un programme, stockant le nom de la fonction et l'adresse de retour.
23. **Probl√®me des Tours de Hano√Ø :** R√©solvez les Tours de Hano√Ø de mani√®re it√©rative en utilisant trois piles pour repr√©senter les piquets.
24. **Backtracking (Labyrinthe) :** Utilisez une pile de coordonn√©es pour trouver la sortie d'un labyrinthe et pouvoir revenir en arri√®re en cas de cul-de-sac.
25. **Navigateur Web :** Simulez l'historique d'un navigateur avec deux piles : une pour "Pr√©c√©dent" et une pour "Suivant".

---

### Pourquoi la Pile est cruciale pour toi ?

Ma√Ætriser la pile, c'est comprendre comment le langage C lui-m√™me fonctionne. Quand tu appelles une fonction, le C fait un `push` de l'adresse de retour et des variables locales. Quand la fonction finit, il fait un `pop`.

**Le d√©fi ultime :** L'exercice **21 (DFS It√©ratif)**. Si tu arrives √† transformer une fonction r√©cursive complexe en une boucle `while` utilisant une pile manuelle, tu auras compris 100% du lien entre m√©moire et ex√©cution.

**Veux-tu que nous √©crivions ensemble le code d'une "Min Stack" (Exercice 18) ? C'est un grand classique d'entretien technique.**
