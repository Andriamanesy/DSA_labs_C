Excellent choix üëå
La **FILE (queue)** est une structure fondamentale en informatique syst√®me, r√©seau, OS, ordonnanceurs, buffers, etc.
La ma√Ætriser = **FIFO + pointeurs + m√©moire + algorithmique**.

Je te propose **25 exercices progressifs**, **du niveau d√©butant au niveau expert**, pens√©s **niveau 42 / syst√®me / algorithmique**.

üëâ Toujours **sans correction**, uniquement des **√©nonc√©s clairs**, pour te forcer √† r√©fl√©chir et √† manipuler la m√©moire.

---

# üü¢ Niveau 1 ‚Äî Comprendre le principe FIFO (1‚Äì5)

> Objectif : comprendre ce qu‚Äôest une file

### Exercice 1 ‚Äì Concept FIFO

* Explique le principe **First In First Out**
* Donne 3 exemples concrets d‚Äôutilisation d‚Äôune file

---

### Exercice 2 ‚Äì N≈ìud de file

* D√©finis une structure repr√©sentant un √©l√©ment de file :

  * une valeur
  * un pointeur vers l‚Äô√©l√©ment suivant

---

### Exercice 3 ‚Äì File vide

* √âcris une fonction qui v√©rifie si la file est vide

---

### Exercice 4 ‚Äì Enqueue (ajout)

* Impl√©mente l‚Äôop√©ration d‚Äôajout en fin de file
* Mets √† jour correctement les pointeurs

---

### Exercice 5 ‚Äì Dequeue (retrait)

* Impl√©mente l‚Äôop√©ration de retrait en d√©but de file
* Lib√®re la m√©moire correctement

---

# üü° Niveau 2 ‚Äî Op√©rations essentielles (6‚Äì10)

> Objectif : manipuler t√™te et queue

### Exercice 6 ‚Äì Peek

* Impl√©mente une fonction qui retourne l‚Äô√©l√©ment en t√™te
* Sans le retirer

---

### Exercice 7 ‚Äì Taille de la file

* √âcris une fonction qui retourne le nombre d‚Äô√©l√©ments

---

### Exercice 8 ‚Äì Affichage

* Affiche la file de la t√™te vers la queue

---

### Exercice 9 ‚Äì Gestion des cas limites

* G√®re les cas :

  * dequeue sur file vide
  * enqueue avec allocation √©chou√©e

---

### Exercice 10 ‚Äì Nettoyage

* Lib√®re enti√®rement la file
* La file finale doit √™tre vide

---

# üü† Niveau 3 ‚Äî Utilisation algorithmique (11‚Äì15)

> Objectif : utiliser la file dans des algorithmes

### Exercice 11 ‚Äì Simulation

* Simule une file d‚Äôattente (clients, impressions, etc.)

---

### Exercice 12 ‚Äì Ordonnancement

* Impl√©mente un ordonnanceur **FIFO**
* Chaque t√¢che a une dur√©e

---

### Exercice 13 ‚Äì Parcours en largeur (BFS)

* Impl√©mente le parcours BFS d‚Äôun graphe
* Utilise une file

---

### Exercice 14 ‚Äì Producteur / consommateur

* Simule un producteur et un consommateur
* Utilise une file partag√©e

---

### Exercice 15 ‚Äì Priorit√© simple

* Impl√©mente une file √† priorit√© simple
* Sans utiliser de heap

---

# üîµ Niveau 4 ‚Äî Impl√©mentations avanc√©es (16‚Äì20)

> Objectif : robustesse et abstraction

### Exercice 16 ‚Äì File avec tableau

* Impl√©mente une file avec un tableau circulaire
* G√®re les indices

---

### Exercice 17 ‚Äì Redimensionnement

* Rends la file dynamique
* Elle doit s‚Äôagrandir automatiquement

---

### Exercice 18 ‚Äì File g√©n√©rique

* Impl√©mente une file utilisant `void *`
* G√®re la taille des √©l√©ments

---

### Exercice 19 ‚Äì Callback

* Passe une fonction en param√®tre
* Applique-la √† chaque √©l√©ment de la file

---

### Exercice 20 ‚Äì S√©curit√© m√©moire

* V√©rifie ton code avec `valgrind`
* Corrige toutes les erreurs

---

# üî¥ Niveau 5 ‚Äî Expert / Syst√®me (21‚Äì25)

> Objectif : niveau professionnel

### Exercice 21 ‚Äì File de structures

* Utilise une file pour stocker des structures complexes

---

### Exercice 22 ‚Äì File thread-safe

* Rends ta file utilisable en multi-thread
* Utilise mutex et condition

---

### Exercice 23 ‚Äì Pipeline

* Impl√©mente un pipeline de traitement
* Chaque √©tape utilise une file

---

### Exercice 24 ‚Äì Ordonnancement avanc√©

* Impl√©mente une file √† priorit√© multi-niveaux
* Simule un ordonnanceur OS

---

### Exercice 25 ‚Äì Mini-projet (üî•)

* Impl√©mente un **serveur de requ√™tes**
* Les requ√™tes arrivent dans une file
* Traitement FIFO
* Gestion m√©moire parfaite
* Code s√©par√© `.h / .c`

---

## üéØ M√©thode recommand√©e

* Toujours visualiser **t√™te ‚Üí queue**
* Tester chaque op√©ration isol√©ment
* V√©rifier tous les cas limites
* Utiliser `valgrind`

---

Si tu veux ensuite :

* corrections d√©taill√©es
* version **liste cha√Æn√©e**
* version **tableau circulaire**
* version **g√©n√©rique**
* exercices bonus type **exam 42**

Dis-moi üî•
=======
La **File (Queue)** est le pendant du "FIFO" (*First In, First Out*). C'est la structure indispensable pour la gestion des processus, les buffers r√©seau et les simulations de flux. En C, elle est plus complexe √† impl√©menter qu'une pile car elle n√©cessite souvent de g√©rer deux extr√©mit√©s (t√™te et queue) ou de jongler avec l'arithm√©tique modulaire (files circulaires).

Voici 25 exercices pour ma√Ætriser les Files.

---

### I. Impl√©mentations Fondamentales

1. **File Statique (Tableau) :** Impl√©mentez une file avec un tableau fixe. G√©rez le d√©calage des √©l√©ments √† chaque retrait (attention √† la complexit√© ).
2. **File Circulaire (Tableau) :** Optimisez l'exercice pr√©c√©dent en utilisant deux indices (`head` et `tail`) et l'op√©rateur modulo `%` pour √©viter de d√©caler les √©l√©ments (complexit√© ).
3. **File par Liste Cha√Æn√©e :** Impl√©mentez une file utilisant une liste simplement cha√Æn√©e avec un pointeur sur `front` et un sur `rear`.
4. **File Dynamique :** Cr√©ez une file sur base de tableau qui se r√©alloue (double sa taille) lorsqu'elle est pleine.
5. **File G√©n√©rique :** Impl√©mentez une file capable de stocker des `void *` pour accepter n'importe quel type de donn√©e.

### II. Algorithmes de Manipulation

6. **Inverser une File :** Inversez l'ordre des √©l√©ments d'une file en utilisant uniquement une pile comme structure auxiliaire.
7. **Rotation de File :** √âcrivez une fonction qui d√©place les  premiers √©l√©ments √† la fin de la file.
8. **V√©rification de File Tri√©e :** V√©rifiez si les √©l√©ments d'une file sont dans un ordre sp√©cifique sans utiliser de structure de donn√©es suppl√©mentaire (uniquement par retraits/ajouts).
9. **Intercaler deux files :** Prenez deux files et fusionnez-les en alternant les √©l√©ments (ex:  et ).
10. **G√©n√©rateur de Nombres Binaires :** Utilisez une file pour g√©n√©rer et afficher les nombres binaires de 1 √† .

### III. Files √† Priorit√© et Variantes

11. **File de Priorit√© Simple :** Impl√©mentez une file o√π chaque √©l√©ment a une priorit√©. L'√©l√©ment avec la plus haute priorit√© est toujours retir√© en premier.
12. **Deque (Double-Ended Queue) :** Impl√©mentez une file o√π l'on peut ajouter et retirer des √©l√©ments aux deux extr√©mit√©s (t√™te et queue).
13. **File de Priorit√© avec Tas (Heap) :** (Avanc√©) Optimisez votre file de priorit√© en utilisant un tas binaire pour obtenir des performances en .
14. **File √† deux piles :** Impl√©mentez une file en utilisant exclusivement deux piles (exercice miroir de celui des piles).
15. **File de structures complexes :** G√©rez une file de "T√¢ches" (`struct Task`) contenant un ID, une priorit√© et un pointeur de fonction.

### IV. Applications Pratiques et Syst√®mes

16. **Buffer Circulaire (Ring Buffer) :** Cr√©ez un buffer de communication o√π les nouvelles donn√©es √©crasent les anciennes si le buffer est plein.
17. **Simulation de File d'Attente :** Simulez une caisse de supermarch√© o√π des clients arrivent √† intervalles al√©atoires. Calculez le temps d'attente moyen.
18. **Parcours en Largeur (BFS) :** Utilisez une file pour parcourir un arbre binaire ou un graphe niveau par niveau.
19. **Syst√®me de Cache "LRU" (Simple) :** Utilisez une file pour simuler un cache o√π l'√©l√©ment le plus ancien est supprim√© quand on ajoute un nouvel √©l√©ment.
20. **Gestionnaire d'Impression :** Simulez un serveur d'impression qui g√®re des documents de tailles diff√©rentes selon l'ordre d'arriv√©e.

### V. D√©fis Avanc√©s

21. **Queue avec "Min" constant :** Impl√©mentez une file qui permet de r√©cup√©rer la valeur minimale pr√©sente dans la file en .
22. **File Circulaire de Taille Variable :** Impl√©mentez un Ring Buffer qui peut se redimensionner sans perdre l'ordre circulaire des donn√©es.
23. **Partition de File :** S√©parez une file d'entiers en deux files : une contenant les nombres pairs, l'autre les impairs.
24. **Multi-File de Priorit√© :** Cr√©ez une structure qui g√®re 3 files internes (Priorit√© Haute, Moyenne, Basse) et vide la haute avant de passer √† la moyenne.
25. **L'it√©rateur de File :** Impl√©mentez un m√©canisme permettant de parcourir les √©l√©ments d'une file sans les d√©truire (sans faire de `pop`).

---

### Le pi√®ge √† √©viter en C

Le plus difficile avec les files en tableau, c'est la **"d√©rive" des indices**. Si tu n'utilises pas une file circulaire, tes indices `head` et `tail` vont finir par sortir du tableau m√™me s'il reste de la place au d√©but. L'exercice **2 (File Circulaire)** est celui qui te fera comprendre l'importance de l'arithm√©tique modulaire.

**Par quoi souhaites-tu commencer ? Si tu veux, je peux te donner le code de d√©part pour l'exercice 2 (le modulo est magique ici !).**
